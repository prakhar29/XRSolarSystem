<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Solar System Explorer</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display:block; padding: 5px; background-color: rgba(0,0,0,0.5); }
        a { color: #0af }
        #vr-button-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 101; }
        /* Basic VR Button Styling */
         #VRButton { background-color: #2a2; color: white; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px; }
         #VRButton:hover { background-color: #3b3; }
         #VRButton:disabled { background-color: #555; cursor: not-allowed; }

         /* Styling for the 2D Info Panel (Keep styles, but element won't be used yet) */
         #infoPanel {
            position: absolute; /* Needed for CSS2DRenderer */
            background-color: rgba(0, 20, 40, 0.85);
            border: 1px solid #0af;
            border-radius: 10px;
            padding: 15px;
            color: white;
            width: 250px; /* Adjust width as needed */
            font-size: 14px;
            text-align: left;
            /* Initially hidden */
            display: none;
            /* Pointer events none so it doesn't block raycasting when visible */
            pointer-events: none;
         }
         #infoPanel h3 { margin-top: 0; color: #0af; }
         #infoPanel p { margin-bottom: 5px; }
         #infoPanel .close-button {
            position: absolute; top: 5px; right: 5px; cursor: pointer; font-weight: bold; color: #aaa;
         }
         #infoPanel .close-button:hover { color: #fff; }

    </style>
</head>
<body>
    <div id="info">
        WebXR Solar System Explorer V0.15<br/>
        Point controller & Press Trigger/Select on a planet for info. Thumbstick to move.
    </div>
     <div id="vr-button-container"></div>

     <!-- Div for the 2D Info Panel (Keep div, but object creation is commented out) -->
     <div id="infoPanel">
        <span id="closeInfoPanel" class="close-button" style="display: none;">[X]</span>
        <h3 id="panelTitle">Planet Name</h3>
        <p id="panelFact1">Fact 1</p>
        <p id="panelFact2">Fact 2</p>
        <p id="panelFact3">Fact 3</p>
     </div>


    <!-- Import Map for Three.js using jsdelivr -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        // import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js'; // Keep commented out
        // import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js'; // Keep commented out

        // --- Basic Setup ---
        let scene, camera, renderer, clock;
        let vrButton;
        let userGroup;
        let controller1, controller2; // Removed controllerGrip vars as models are removed
        let controllerLine; // Reference to the line on controller1
        const movementSpeed = 2.0;

        // --- Interaction ---
        let raycaster;
        let intersectedObject = null; // Track the currently pointed-at planet
        const highlightColor = new THREE.Color(0x00ff00); // Green highlight
        const defaultLineColor = new THREE.Color(0xffffff); // White default

        // --- 2D UI (Keep vars, but objects/renderer not created) ---
        // let css2DRenderer;
        let infoPanelDiv; // Keep reference to the div element
        // let infoPanelObject;
        let selectedPlanet = null; // Keep track of selected planet

        // --- Solar System Data ---
        const solarSystemData = [
            { name: 'Sun', radius: 5, distance: 0, speed: 0, color: 0xffd700, emissive: 0xffd700, facts: ["Star", "Center of Solar System", "Surface Temp: ~5,500 Â°C"] },
            { name: 'Mercury', radius: 0.5, distance: 15, speed: 0.047, color: 0xaaaaaa, facts: ["Smallest Planet", "Shortest Orbit (88 days)", "Extreme Temperatures"] },
            { name: 'Venus', radius: 0.9, distance: 22, speed: 0.035, color: 0xffe4b5, facts: ["Hottest Planet", "Thick CO2 Atmosphere", "Rotates Backwards"] },
            { name: 'Earth', radius: 1, distance: 30, speed: 0.029, color: 0x4682b4, facts: ["Our Home", "Only Known Life", "Liquid Water Surface"] },
            { name: 'Mars', radius: 0.7, distance: 40, speed: 0.024, color: 0xff4500, facts: ["The Red Planet", "Olympus Mons (Volcano)", "Thin Atmosphere"] },
            { name: 'Jupiter', radius: 3.5, distance: 65, speed: 0.013, color: 0xffa500, facts: ["Largest Planet", "Great Red Spot (Storm)", "Gas Giant"] },
            { name: 'Saturn', radius: 3, distance: 90, speed: 0.009, color: 0xf4a460, facts: ["Ringed Planet", "Least Dense Planet", "Gas Giant"] },
            { name: 'Uranus', radius: 2, distance: 115, speed: 0.006, color: 0xadd8e6, facts: ["Ice Giant", "Tilted Axis", "Faint Rings"] },
            { name: 'Neptune', radius: 1.9, distance: 140, speed: 0.005, color: 0x00008b, facts: ["Ice Giant", "Strongest Winds", "Great Dark Spot (Variable)"] }
        ];

        const planetObjects = []; // Stores { mesh, orbitGroup, speed, distance, data }
        const selectablePlanets = []; // Stores just the planet meshes for raycasting

        // --- Function Definitions ---

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock(); // Keep clock for movement delta

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Use minimal renderer settings
            renderer = new THREE.WebGLRenderer({
                 antialias: false // AA Disabled
            });
            renderer.setPixelRatio( 1 ); // Force 1.0 pixel ratio (simplest)
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // --- REMOVED CSS2D RENDERER SETUP ---
            /*
            css2DRenderer = new CSS2DRenderer();
            css2DRenderer.setSize(window.innerWidth, window.innerHeight);
            css2DRenderer.domElement.style.position = 'absolute';
            css2DRenderer.domElement.style.top = '0px';
            css2DRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(css2DRenderer.domElement);
            */

            // User Group (Keep for movement)
            userGroup = new THREE.Group();
            userGroup.position.set(0, 5, 45);
            userGroup.add(camera);
            scene.add(userGroup);

            // VR Button (Keep)
            vrButton = VRButton.createButton(renderer);
            document.getElementById('vr-button-container').appendChild(vrButton);

            // Controllers (Setup for movement AND interaction events)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart); // <-- RE-ENABLED
            controller1.addEventListener('selectend', onSelectEnd);     // <-- RE-ENABLED
            userGroup.add(controller1);

            controller2 = renderer.xr.getController(1);
            userGroup.add(controller2);

            // --- REMOVED CONTROLLER MODELS ---

             // --- RE-ENABLED CONTROLLER LINE / RAYCASTER ---
             const controllerLineMat = new THREE.LineBasicMaterial({ color: defaultLineColor, linewidth: 2 });
             const controllerLineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -10) ]);
             controllerLine = new THREE.Line(controllerLineGeom, controllerLineMat);
             controller1.add(controllerLine); // <-- RE-ENABLED

             raycaster = new THREE.Raycaster(); // <-- RE-ENABLED

            // --- Lighting (Keep minimal) ---
            const ambientLight = new THREE.AmbientLight( 0xffffff, 1.5 );
            scene.add(ambientLight);

            // --- RE-ENABLE SOLAR SYSTEM CREATION CALL ---
            createSolarSystem(); // Keep uncommented

            // --- RE-ENABLE STARFIELD CREATION CALL ---
            createStarfield(); // Keep uncommented

            // --- REMOVED UI PANEL OBJECT CREATION ---
            infoPanelDiv = document.getElementById('infoPanel'); // Still get reference to div if needed later
            /*
            infoPanelObject = new CSS2DObject(infoPanelDiv);
            infoPanelObject.position.set(0, 0, 0);
            scene.add(infoPanelObject);
            */

            window.addEventListener('resize', onWindowResize, false); // Keep resize
        } // End of init function

        function createSolarSystem() {
            solarSystemData.forEach(data => {
                const isSun = data.name === 'Sun';
                // Optimized Sphere Geometry
                const geometry = new THREE.SphereGeometry(data.radius, 24, 12);
                // Optimized Basic Material
                const material = new THREE.MeshBasicMaterial({ color: data.color });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = data.name;
                mesh.userData = data;

                let orbitGroup = null;
                if (!isSun) {
                    orbitGroup = new THREE.Group();
                    scene.add(orbitGroup);
                    mesh.position.x = data.distance;
                    orbitGroup.add(mesh);

                     // Optimized Orbit Ring Geometry
                     const orbitPathGeometry = new THREE.RingGeometry(data.distance - 0.1, data.distance + 0.1, 64);
                     orbitPathGeometry.rotateX(-Math.PI / 2);
                     const orbitPathMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.15, transparent: true, side: THREE.DoubleSide });
                     const orbitPathMesh = new THREE.Mesh(orbitPathGeometry, orbitPathMaterial);
                     scene.add(orbitPathMesh);

                    selectablePlanets.push(mesh);
                } else {
                    scene.add(mesh); // Add sun directly
                }

                planetObjects.push({
                    mesh: mesh, orbitGroup: orbitGroup, speed: data.speed, distance: data.distance, data: data
                });

                // Special case: Saturn's Rings (Optimized Geometry)
                if (data.name === 'Saturn') {
                    const ringGeometry = new THREE.RingGeometry(data.radius * 1.2, data.radius * 2.2, 32);
                    ringGeometry.rotateX(Math.PI * 0.45); ringGeometry.rotateY(Math.PI * 0.1);
                    const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    mesh.add(ringMesh);
                }
            });
        } // End of createSolarSystem

        function createStarfield() {
            // Optimized Star Count
            const numStars = 5000;
            const starRadius = 500;
            const starVertices = [];
            for (let i = 0; i < numStars; i++) {
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                const x = starRadius * Math.sin(phi) * Math.cos(theta);
                const y = starRadius * Math.sin(phi) * Math.sin(theta);
                const z = starRadius * Math.cos(phi);
                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff, size: 0.7, sizeAttenuation: true,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        } // End of createStarfield

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // No need to resize css2DRenderer as it's not created
        } // End of onWindowResize

        function handleControllerInput(controller, delta) {
            // Basic movement logic (no changes needed here)
            if (controller.userData.gamepad) {
                const gamepad = controller.userData.gamepad;
                if (gamepad.axes.length >= 4) {
                    const moveZ = gamepad.axes[3];
                    if (Math.abs(moveZ) > 0.1) {
                        const moveDirection = new THREE.Vector3(0, 0, -1);
                        moveDirection.applyQuaternion(controller.quaternion);
                        // moveDirection.y = 0; // Optional: Prevent vertical movement
                        // moveDirection.normalize();
                        userGroup.position.addScaledVector(moveDirection, -moveZ * movementSpeed * delta);
                    }
                }
            }
        } // End of handleControllerInput

    function updateInteractions() {
        intersectedObject = null; // Reset intersection (doesn't matter now but keep for structure)

        // Check controller1 exists before using it
        if (renderer.xr.isPresenting && controller1 && controllerLine) {
            // --- Keep Raycaster Setup ---
            const controllerMatrix = controller1.matrixWorld;
            const rayDirection = new THREE.Vector3(0, 0, -1).applyMatrix4(controllerMatrix).sub(controllerMatrix.getPosition(new THREE.Vector3()));
            raycaster.set(controllerMatrix.getPosition(new THREE.Vector3()), rayDirection.normalize());

            // --- TEMPORARILY DISABLE INTERSECTION TEST ---
            /*
            const intersects = raycaster.intersectObjects(selectablePlanets, false);

            if (intersects.length > 0) {
                intersectedObject = intersects[0].object;
                controllerLine.material.color.set(highlightColor);
            } else {
                 controllerLine.material.color.set(defaultLineColor);
            }
            */

            // Force line color to default for this test
            controllerLine.material.color.set(defaultLineColor);


        } else if (controllerLine) { // Reset color if not presenting or no controller
             controllerLine.material.color.set(defaultLineColor);
        }
    } // End of updateInteractions

        function onSelectStart() {
             // Triggered by controller button press
             // Only log for now, no UI manipulation
             if (intersectedObject) {
                 console.log("Selected:", intersectedObject.name);
                 selectedPlanet = intersectedObject; // Keep track of selection
                 // NO UI panel manipulation here yet
             } else {
                 console.log("Selected empty space");
                 selectedPlanet = null;
                 // NO UI panel manipulation here yet
             }
         } // End of onSelectStart

         function onSelectEnd() {
            // Optional: Could add logic here if needed on release
            // console.log("Select end");
         } // End of onSelectEnd

        function animate() {
            renderer.setAnimationLoop(() => { // Arrow function for loop starts
                const delta = clock.getDelta(); // Keep for movement and animation

                // --- Planet Orbit Loop (Keep) ---
                if (window.planetObjects && planetObjects.length > 0) { // Check if array exists
                    planetObjects.forEach(obj => { // Loop through planets
                        // Orbiting
                        if (obj.orbitGroup) { // Check if it has orbit group
                            obj.orbitGroup.rotation.y += obj.speed * delta * 5;
                        } // End if orbitGroup
                        // Self-rotation
                        obj.mesh.rotation.y += 0.1 * delta;
                    }); // End forEach planet
                 } // End if planetObjects exist

                 // Handle VR Controller Input for Movement & Interactions
                 if (renderer.xr.isPresenting) { // Check if in VR
                     // Gamepad Update & Movement Logic (Keep)
                     const session = renderer.xr.getSession();
                     if (session && session.inputSources) { // Check session and input sources
                          let primaryController = null;
                          session.inputSources.forEach((source, index) => { // Loop through sources
                              const targetController = (index === 0) ? controller1 : controller2;
                              if (targetController) { // Check if controller object exists
                                  targetController.userData.gamepad = source.gamepad || null;
                                  if (source.gamepad && !primaryController) { // Check if gamepad exists and primary not set
                                     primaryController = targetController;
                                  } // End if source.gamepad
                              } // End if targetController
                          }); // End forEach source

                           const moveController = primaryController || controller2;
                           if (moveController) { // Check if we have a controller for movement
                              handleControllerInput(moveController, delta);
                           } // End if moveController
                     } // End if session and inputSources

                     // --- RE-ENABLED INTERACTION UPDATES ---
                     updateInteractions(); // <-- RE-ENABLED THIS CALL

                     // --- REMOVED UI PANEL POSITIONING ---
                     /*
                     if (selectedPlanet && infoPanelDiv.style.display === 'block') {
                         // ... panel positioning ... // Keep commented out
                     }
                     */
                 } // End if isPresenting

                // Render Scene (Keep)
                renderer.render(scene, camera);

                // --- REMOVED CSS2D RENDER CALL ---
                // css2DRenderer.render(scene, camera); // Keep commented out
            }); // End of setAnimationLoop callback
        } // End of animate function

        // --- Start the experience ---
        init();
        animate();

    </script> // End of module script
</body>
</html>
