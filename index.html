<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR Solar System Explorer</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display:block; padding: 5px; background-color: rgba(0,0,0,0.5); }
        a { color: #0af }
        #vr-button-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 101; }
        /* Basic VR Button Styling */
         #VRButton { background-color: #2a2; color: white; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px; }
         #VRButton:hover { background-color: #3b3; }
         #VRButton:disabled { background-color: #555; cursor: not-allowed; }

         /* Styling for the 2D Info Panel */
         #infoPanel {
            position: absolute; /* Needed for CSS2DRenderer */
            background-color: rgba(0, 20, 40, 0.85);
            border: 1px solid #0af;
            border-radius: 10px;
            padding: 15px;
            color: white;
            width: 250px; /* Adjust width as needed */
            font-size: 14px;
            text-align: left;
            /* Initially hidden */
            display: none;
            /* Pointer events none so it doesn't block raycasting when visible */
            pointer-events: none;
         }
         #infoPanel h3 { margin-top: 0; color: #0af; }
         #infoPanel p { margin-bottom: 5px; }
         #infoPanel .close-button { /* Basic styling for a potential close button if needed */
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #aaa;
         }
         #infoPanel .close-button:hover { color: #fff; }

    </style>
</head>
<body>
    <div id="info">
        WebXR Solar System Explorer V0.10<br/>
        Point controller & Press Trigger/Select on a planet for info. Thumbstick to move.
    </div>
     <div id="vr-button-container"></div>

     <!-- Div for the 2D Info Panel -->
     <div id="infoPanel">
        <span id="closeInfoPanel" class="close-button" style="display: none;">[X]</span> <!-- Example close button, functionality not fully added -->
        <h3 id="panelTitle">Planet Name</h3>
        <p id="panelFact1">Fact 1</p>
        <p id="panelFact2">Fact 2</p>
        <p id="panelFact3">Fact 3</p>
     </div>


    <!-- Import Map for Three.js using jsdelivr -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js'; // Import CSS2D

        // --- Basic Setup ---
        let scene, camera, renderer, clock;
        let vrButton;
        let userGroup;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let controllerLine; // Reference to the line on controller1
        const movementSpeed = 2.0;

        // --- Interaction ---
        let raycaster;
        let intersectedObject = null; // Track the currently pointed-at planet
        const highlightColor = new THREE.Color(0x00ff00); // Green highlight
        const defaultLineColor = new THREE.Color(0xffffff); // White default

        // --- 2D UI ---
        let css2DRenderer;
        let infoPanelDiv;
        let infoPanelObject;
        let selectedPlanet = null; // Track the currently selected planet for UI

        // --- Solar System Data ---
        // Added color and basic facts. Removed texture URLs.
        const solarSystemData = [
            { name: 'Sun', radius: 5, distance: 0, speed: 0, color: 0xffd700, emissive: 0xffd700, facts: ["Star", "Center of Solar System", "Surface Temp: ~5,500 Â°C"] },
            { name: 'Mercury', radius: 0.5, distance: 15, speed: 0.047, color: 0xaaaaaa, facts: ["Smallest Planet", "Shortest Orbit (88 days)", "Extreme Temperatures"] },
            { name: 'Venus', radius: 0.9, distance: 22, speed: 0.035, color: 0xffe4b5, facts: ["Hottest Planet", "Thick CO2 Atmosphere", "Rotates Backwards"] },
            { name: 'Earth', radius: 1, distance: 30, speed: 0.029, color: 0x4682b4, facts: ["Our Home", "Only Known Life", "Liquid Water Surface"] },
            { name: 'Mars', radius: 0.7, distance: 40, speed: 0.024, color: 0xff4500, facts: ["The Red Planet", "Olympus Mons (Volcano)", "Thin Atmosphere"] },
            { name: 'Jupiter', radius: 3.5, distance: 65, speed: 0.013, color: 0xffa500, facts: ["Largest Planet", "Great Red Spot (Storm)", "Gas Giant"] },
            { name: 'Saturn', radius: 3, distance: 90, speed: 0.009, color: 0xf4a460, facts: ["Ringed Planet", "Least Dense Planet", "Gas Giant"] }, // Ring added separately
            { name: 'Uranus', radius: 2, distance: 115, speed: 0.006, color: 0xadd8e6, facts: ["Ice Giant", "Tilted Axis", "Faint Rings"] },
            { name: 'Neptune', radius: 1.9, distance: 140, speed: 0.005, color: 0x00008b, facts: ["Ice Giant", "Strongest Winds", "Great Dark Spot (Variable)"] }
        ];

        const planetObjects = []; // Stores { mesh, orbitGroup, speed, distance, data }
        const selectablePlanets = []; // Stores just the planet meshes for raycasting

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock(); // Keep clock for movement delta

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Use minimal renderer settings
            renderer = new THREE.WebGLRenderer({
                 antialias: false // AA Disabled
            });
            renderer.setPixelRatio( 1 ); // Force 1.0 pixel ratio (simplest)
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // --- REMOVED CSS2D RENDERER SETUP ---
            /*
            css2DRenderer = new CSS2DRenderer();
            css2DRenderer.setSize(window.innerWidth, window.innerHeight);
            css2DRenderer.domElement.style.position = 'absolute';
            css2DRenderer.domElement.style.top = '0px';
            css2DRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(css2DRenderer.domElement);
            */

            // User Group (Keep for movement)
            userGroup = new THREE.Group();
            userGroup.position.set(0, 5, 45);
            userGroup.add(camera);
            scene.add(userGroup);

            // VR Button (Keep)
            vrButton = VRButton.createButton(renderer);
            document.getElementById('vr-button-container').appendChild(vrButton);

            // Controllers (Setup for movement ONLY, no models, no select events)
            controller1 = renderer.xr.getController(0);
            // controller1.addEventListener('selectstart', onSelectStart); // REMOVED
            // controller1.addEventListener('selectend', onSelectEnd); // REMOVED
            userGroup.add(controller1);

            controller2 = renderer.xr.getController(1);
            userGroup.add(controller2);

            // --- REMOVED CONTROLLER MODELS ---
            // --- REMOVED CONTROLLER LINE / RAYCASTER ---
             /*
             const controllerLineMat = new THREE.LineBasicMaterial({...});
             const controllerLineGeom = new THREE.BufferGeometry()...;
             controllerLine = new THREE.Line(...);
             controller1.add(controllerLine);
             raycaster = new THREE.Raycaster();
            */

            // --- Lighting (Keep minimal) ---
            const ambientLight = new THREE.AmbientLight( 0xffffff, 1.5 );
            scene.add(ambientLight);

            // --- REMOVED SOLAR SYSTEM CREATION CALL ---
            createSolarSystem();

            // --- REMOVED STARFIELD CREATION CALL ---
            createStarfield();

            // --- REMOVED UI PANEL OBJECT CREATION ---
            /*
            infoPanelDiv = document.getElementById('infoPanel');
            infoPanelObject = new CSS2DObject(infoPanelDiv);
            infoPanelObject.position.set(0, 0, 0);
            scene.add(infoPanelObject);
            */

            window.addEventListener('resize', onWindowResize, false); // Keep resize
        }
        
        function createSolarSystem() {
            solarSystemData.forEach(data => {
                const isSun = data.name === 'Sun';
                // --- OPTIMIZATION: Reduce Sphere Segments ---
                const geometry = new THREE.SphereGeometry(
                    data.radius,
                    12, // Reduced width segments (from 32)
                    6  // Reduced height segments (from 16)
                 );

                let material;
                // --- OPTIMIZATION: Use MeshBasicMaterial for planets ---
                material = new THREE.MeshBasicMaterial({
                    color: data.color,
                    // No lighting calculations needed for BasicMaterial
                });
                // We no longer need the distinction between Sun and Planet material types
                // as both will be MeshBasicMaterial.

                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = data.name;
                mesh.userData = data;

                let orbitGroup = null;
                if (!isSun) {
                    orbitGroup = new THREE.Group();
                    scene.add(orbitGroup);
                    mesh.position.x = data.distance;
                    orbitGroup.add(mesh);

                     // --- OPTIMIZATION: Reduce Orbit Ring Segments ---
                     const orbitPathGeometry = new THREE.RingGeometry(
                         data.distance - 0.1,
                         data.distance + 0.1,
                         64 // Reduced segments (from 128)
                     );
                     orbitPathGeometry.rotateX(-Math.PI / 2);
                     const orbitPathMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.15, transparent: true, side: THREE.DoubleSide });
                     const orbitPathMesh = new THREE.Mesh(orbitPathGeometry, orbitPathMaterial);
                     scene.add(orbitPathMesh);

                    selectablePlanets.push(mesh);

                } else {
                    scene.add(mesh); // Add sun directly
                }

                planetObjects.push({
                    mesh: mesh,
                    orbitGroup: orbitGroup,
                    speed: data.speed,
                    distance: data.distance,
                    data: data
                });

                // Special case: Saturn's Rings (already BasicMaterial, reduce geometry)
                if (data.name === 'Saturn') {
                     // --- OPTIMIZATION: Reduce Ring Segments ---
                    const ringGeometry = new THREE.RingGeometry(
                        data.radius * 1.2,
                        data.radius * 2.2,
                        32 // Reduced segments (from 64)
                     );
                    ringGeometry.rotateX(Math.PI * 0.45);
                    ringGeometry.rotateY(Math.PI * 0.1);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0xcccccc,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.6
                     });
                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    mesh.add(ringMesh);
                }
            });
        }
        function createStarfield() {
            // --- OPTIMIZATION: Reduce Star Count ---
            const numStars = 5000; // Reduced from 10000
            const starRadius = 500;

            const starVertices = [];
            for (let i = 0; i < numStars; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const x = starRadius * Math.sin(phi) * Math.cos(theta);
                const y = starRadius * Math.sin(phi) * Math.sin(theta);
                const z = starRadius * Math.cos(phi);
                starVertices.push(x, y, z);
            }

            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7, // Keep size for visibility
                sizeAttenuation: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            css2DRenderer.setSize(window.innerWidth, window.innerHeight); // Resize CSS2D renderer too
        }

        function handleControllerInput(controller, delta) {
            if (controller.userData.gamepad) {
                const gamepad = controller.userData.gamepad;
                if (gamepad.axes.length >= 4) {
                    const moveZ = gamepad.axes[3];
                    if (Math.abs(moveZ) > 0.1) {
                        const moveDirection = new THREE.Vector3(0, 0, -1);
                        moveDirection.applyQuaternion(controller.quaternion);
                        // moveDirection.y = 0; // Optional: Prevent vertical movement
                        // moveDirection.normalize();
                        userGroup.position.addScaledVector(moveDirection, -moveZ * movementSpeed * delta);
                    }
                }
            }
        }

        function updateInteractions() {
            intersectedObject = null; // Reset intersection
            if (renderer.xr.isPresenting && controller1) {
                // Use controller's matrix world for raycasting
                const controllerMatrix = controller1.matrixWorld;
                const rayDirection = new THREE.Vector3(0, 0, -1).applyMatrix4(controllerMatrix).sub(controllerMatrix.getPosition(new THREE.Vector3()));

                raycaster.set(controllerMatrix.getPosition(new THREE.Vector3()), rayDirection.normalize());

                const intersects = raycaster.intersectObjects(selectablePlanets, false); // Intersect only planet meshes

                if (intersects.length > 0) {
                    // Check if the intersection is different from the last frame
                    if (intersectedObject !== intersects[0].object) {
                       intersectedObject = intersects[0].object;
                    }
                     // Highlight: Change controller line color
                    controllerLine.material.color.set(highlightColor);

                } else {
                     // No intersection: Reset line color
                     controllerLine.material.color.set(defaultLineColor);
                }
            } else {
                 // Not presenting or no controller, reset line color
                 if(controllerLine) controllerLine.material.color.set(defaultLineColor);
            }
        }


        function onSelectStart() {
             // Triggered by controller button press
             if (intersectedObject) {
                 selectedPlanet = intersectedObject; // Mark this planet as selected
                 const data = selectedPlanet.userData; // Get the data stored on the mesh

                 // Update the HTML panel content
                 document.getElementById('panelTitle').textContent = data.name;
                 document.getElementById('panelFact1').textContent = data.facts[0] || '';
                 document.getElementById('panelFact2').textContent = data.facts[1] || '';
                 document.getElementById('panelFact3').textContent = data.facts[2] || '';

                 // Position the panel slightly above the selected planet
                 const planetPosition = selectedPlanet.getWorldPosition(new THREE.Vector3());
                 const offset = new THREE.Vector3(0, selectedPlanet.geometry.parameters.radius + 1.5, 0); // Offset Y based on planet radius + margin
                 infoPanelObject.position.copy(planetPosition).add(offset);

                 // Make the panel visible
                 infoPanelDiv.style.display = 'block';
             } else {
                 // Clicked in empty space, hide the panel
                 selectedPlanet = null;
                 infoPanelDiv.style.display = 'none';
             }
         }

         function onSelectEnd() {
            // Optional: Hide panel on trigger release? Or keep it until another selection?
            // For now, we'll leave it visible until another selection or empty space click.
         }

        function animate() {
            renderer.setAnimationLoop(() => {
                const delta = clock.getDelta(); // Keep for movement and animation

                // --- RE-ENABLED PLANET ORBIT LOOP ---
                // Check if planetObjects exists and has elements before looping
                if (window.planetObjects && planetObjects.length > 0) {
                    planetObjects.forEach(obj => {
                        // Orbiting: Rotate the group the planet is in
                        if (obj.orbitGroup) {
                            obj.orbitGroup.rotation.y += obj.speed * delta * 5; // Adjust speed multiplier if needed
                        }
                        // Self-rotation: Rotate the planet mesh itself
                        obj.mesh.rotation.y += 0.1 * delta; // Adjust rotation speed if needed
                    });
                 }

                 // Handle VR Controller Input for Movement (Keep basic movement)
                 if (renderer.xr.isPresenting) {
                     const session = renderer.xr.getSession();
                     if (session && session.inputSources) {
                          let primaryController = null; // Find the controller with gamepad first for movement
                          session.inputSources.forEach((source, index) => {
                              const targetController = (index === 0) ? controller1 : controller2;
                              if (targetController) {
                                  targetController.userData.gamepad = source.gamepad || null;
                                  if (source.gamepad && !primaryController) primaryController = targetController; // Assign first controller with gamepad
                              }
                          });
                           // Use primary (gamepad) controller for movement, default to controller2 if needed
                           const moveController = primaryController || controller2;
                           if (moveController) handleControllerInput(moveController, delta); // Keep movement call
                     }

                     // --- REMOVED INTERACTION UPDATES ---
                     // updateInteractions(); // Keep commented out

                     // --- REMOVED UI PANEL POSITIONING ---
                     /*
                     if (selectedPlanet && infoPanelDiv.style.display === 'block') {
                         // ... panel positioning ... // Keep commented out
                     }
                     */
                 }

                // Render Scene (Keep)
                renderer.render(scene, camera);

                // --- REMOVED CSS2D RENDER CALL ---
                // css2DRenderer.render(scene, camera); // Keep commented out
            });
        }
        
    </script>
</body>
</html>
